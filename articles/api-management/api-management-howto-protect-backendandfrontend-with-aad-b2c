---
title: Protect an API and flow custom claims by using OAuth 2.0 with Azure Active Directory and API Management | Microsoft Docs
description: Protect an API by using OAuth 2.0 with Azure Active Directory B2C, API Management and Azure App Service Easy Auth and call it from a JavaScript Single Page App

.
services: api-management
documentationcenter: ''
author: wieastbu
manager: glsmall
editor: ''

ms.service: api-management
ms.workload: mobile
ms.tgt_pltfrm: na
ms.devlang: na
ms.topic: article
ms.date: 12/14/2018
ms.author: apimpm
---

# Protect an API by using OAuth 2.0 with Azure Active Directory B2C, API Management and Azure App Service Easy Auth and call it from a JavaScript Single Page App

This guide shows you how to configure your Azure API Management instance to protect an API, by using the OAuth 2.0 protocol with Azure Active Directory (Azure AD) B2C, and how to flow claims data through API management to be used into a backend function. 

## Aims
The idea of this document is to show how API-Management can be used in a real world scenario with the Azure Functions and AAD B2C services to capture additional data and flow it through API Management.
The basic premise of the document is that there is a JavaScript Single Page Application calling through and retrieving data from the API about the user, in practice you will use this data in the function API tier to feed into some kind of business logic, 
in this case we will simply record a CRMID field as a custom attribute and flow it through API-management to secure the API and validate the JWT in flight.
The ‘logged in as’ is picked up from the client side token when we log in, the ‘Custom Claim’ comes back from the Azure Function code to show that we can decipher the token and use the claim in the function’s business logic.

## Prerequisites
To follow the steps in this article, you must have:
* An Azure v2 Storage Account to host the frontend JS Single Page App
* An API Management instance
* An empty Function app (v1 runtime) to host the back end API (sample code provided)
* An Azure AD B2C tenant, linked to a subscription 

## Overview

Here is a quick overview of the steps:

1. Create the AAD B2C User Attributes to capture the custom claims
2. Create the AAD Calling (Frontend, API-M) and API Applications with scopes and grant API Access
3. Create the Signup or signin policies to allow users to login with AAD B2C
4. Configure API Management with the new AAD B2C Client IDs and keys to Enable OAuth 2.0 user authorization in the Developer Console
5. Build the Function API
6. Configure the Function API to enable EasyAuth with the new AAD B2C Client ID’s and Keys and lock down to APIM VIP 
7. Build the API Definition in API Management
8. Set up Oauth2 for the API-M API configuration
9. Setup CORS and Add the **validate-jwt** policy to validate the OAuth token for every incoming request.
10. Setup the custom claim data
11. Test the API from the APIM Portal 
12. Build the calling application to consume the API
13. Upload the JS SPA Sample
14. Configure the Sample JS Client App with the new AAD B2C Client ID’s and keys 
15. Configure the Function API to serve as a useful reminder countdown
16. Test the Client Application

# Create the AAD B2C User Attributes to capture the custom claims

Before we can capture and flow any custom claims or register the applications that we intend to use, we need to create the AAD B2C user attributes inside the AAD B2C tenant, effectively you just created and assigned application permissions for your calling API.

1. Open the Azure Portal, switch your tenant to the AAD B2C tenant and browse to the **Azure Active Directory B2C** blade 
2. Select the **Overview** tab and record the domain name of the tenant for later use.
3. Select the **User Attributes** tab and add a custom string attribute called CRM_ID of type string

> [!NOTE]
> Custom attributes are accessible from AAD B2C policies and are returned optionally as claims in the auth token that is issued, this is a convenient way of securely storing additional metadata about users in AAD B2C.
> You can also manipulate and read this data as an administrator using the AAD Graph API.

# Create the AAD Calling (Frontend, API-M) and Backend API Applications with scopes and grant API Access

1. Select the **Applications** tab 
2. Click the 'Add' button and create 3 applications
* The Frontend Client, 
* The Backend Function API,
* The API-Management developer portal (unless you are running APIM in consumption mode)

3. Use placeholders for the reply urls for now, we’ll update those later.
4. For the App ID URI simply choose something unique and relevant to the service being created.
5. Set WebApp/ Web API and Allow Implicit flow to yes
6. Record the AppID URI, name and Application ID for later use for all 3 apps.

7. Open the Backend API from the list of applications and select the *Keys* tab (under General) to generate an auth key
8. Record the key somewhere safe for later use
9. Now select the *Published Scopes* Tab (Under API Access)
10. Create and name a scope for your Function API 

> [!NOTE]
> AAD B2C scopes are effectively permissions within your API that other applications can request access to via the API access blade from their applications, effectively you just created and assigned application permissions for your calling API.

11. Open the other 2 applications and under the *API Access* tab, grant them access to the backend API scope (that you just created) and the default one that was already there ("login as user") 
12. Generate them a key each (select the *Keys* tab (under General) to generate an auth key) whilst you are here and record those somewhere safe too.

# Create a "Signup or signin" policy to allow users to login with AAD B2C
1. Return to the root of the AAD B2C Blade 
2. Then select “Sign-up or Sign-in Policies” and click ‘add’
3. Give the policy a name (and record it for later) and select 'Identity providers', then check User ID signup and click OK. 
4. Select 'Signup attributes' and choose the registration options that you want your customers to enter (At a minimum, choose Email, Display Name and Country/Region), then click OK.
5. Select 'Application Claims' and choose 'Country/Region', 'Display Name', CRM_ID, 'User's Object ID' and 'User is new', then click OK.
6. Click OK again to return to the main AAD B2C blade, now select the policy you just created in the list to re-open it, then record the address of the b2clogin.com domain from the .
7. Click on the link at the top for the well-known openid confguration endpoint and record the authorization_endpoint and token_endpoint values from the opened document.

> [!NOTE]
> B2C Policies allow you to expose the AAD B2C login endpoints to be able to capture different data components and log in users in different ways
> In this case we configured a sign up and sign in endpoint, which exposed a well-known condfiguration endpoint, specifically our created policy was identified in the URL by the p= parameter
> Once this is done – you now have a functional Business to Consumer identity platform that will sign users into multiple applications. 

# [Optional] Configure API Management with the new AAD B2C Client IDs and keys to to Enable OAuth 2.0 user authorization in the Developer Console
1. Switch back to your standard AAD tenant in the Azure portal and open the *API management blade*, then open *your instance*.
2. Note down the *Virtual IP (VIP) address* of the instance, and optionally the *developer portal URL* and record them for later.
3. Next, Select the Oauth 2.0  blade from the Security Tab, and click 'Add'
4. Give sensible values for *Display Name* and *Description*
5. You can enter any value in the Client registration page URL, as we will not use it here
6. Check the *Authorization code* and *Implicit Auth* Grant types
7. In the *Authorization* and *Token* endpoint fields enter the values you captured from the well-known configuration xml document earlier.
8. Scroll down and populate an *Additional body parameter* called 'resource' with the Back end Function API client ID from the AAD B2C App registration
9. Set the Client credentials section upSet the Client ID to the APIM Developer console app's application ID and set the Client Secret to the APIM developer console app's Key) 
10. Lastly, now record the redirect_uri of the auth code grant from APIM 'This is what the redirect_uri for authorization code grant looks like' for later use.

> [!NOTE]
> Now we have an API Management instance that knows how to get access tokens from AAD B2C to authorize requests through the developer portal for testing.

# Build the Function API
1. Go to the Function Apps blade of the azure portal, open the function app and create a new http triggered C# function,
2. Set it’s name to HttpTriggerC# and it’s auth level to Anonymous (we will secure this, but not by using a function key or admin key).
3. Paste the sample code from this link into Run.csx over the existing code that appears.
4. Select “Integrate” from the left-hand blade, then select ‘Advanced Editor’.
5. Paste the sample code over the existing json that appears to remove the post method and add the custom route to make the API respond on {http://fnappname.azurewebsites.net/api/celebration}, then click save
6. Reselect the HttpTriggerCSharp1 item from the list on the left hand side, then select the ‘View Files’ tab on the right hand side.
7. Click ‘Add’ and name the file project.json, an empty file will be created.
8. Post the sample code into that file and click save.

> [!NOTE]
> Now we have a very simplistic backend serverless http API, that is capable of validating tokens and returning a simple payload.
> Basically all this function does is checks a few claims on the provided access token and returns some static data for the website to render.
> You should see something like this returned if you are correctly signed in and the value of cclaim_CRM should be set to the custom claim we defined in the AAD B2C configuration, note that if you haven’t set this claim – then the API should throw a 403 Forbidden message at you see the profile editing policy section, if the token is not present then APIM should throw a 401 Unauthorized message.
>{
>   "date":"20181014",
>   "location":"Whatever you choose as the location",
>   "time":"1400",
>   "cclaim_CRM":"Will001"
>}

# Configure the Function API to enable EasyAuth with the new AAD B2C Client ID’s and Keys and lock down to APIM VIP 


-- TBC --

7. Build the API Definition in API Management
8. Set up Oauth2 for the API-M API configuration
9. Setup CORS and Add the **validate-jwt** policy to validate the OAuth token for every incoming request.
10. Setup the custom claim data
11. Test the API from the APIM Portal 
12. Build the calling application to consume the API
13. Upload the JS SPA Sample
14. Configure the Sample JS Client App with the new AAD B2C Client ID’s and keys 
15. Configure the Function API to serve as a useful reminder countdown
16. Test the Client Application

> [!NOTE]
> This section does not apply to the **Consumption** tier, which does not support the developer portal.

Now that the OAuth 2.0 user authorization is enabled on the `Echo API`, the Developer Console obtains an access token on behalf of the user, before calling the API.

1. Browse to any operation under the `Echo API` in the developer portal, and select **Try it**. This brings you to the Developer Console.

2. Note a new item in the **Authorization** section, corresponding to the authorization server you just added.

3. Select **Authorization code** from the authorization drop-down list, and you are prompted to sign in to the Azure AD tenant. If you are already signed in with the account, you might not be prompted.

4. After successful sign-in, an `Authorization` header is added to the request, with an access token from Azure AD. The following is a sample token (Base64 encoded):

   ```
   Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsIng1dCI6IlNTUWRoSTFjS3ZoUUVEU0p4RTJnR1lzNDBRMCIsImtpZCI6IlNTUWRoSTFjS3ZoUUVEU0p4RTJnR1lzNDBRMCJ9.eyJhdWQiOiIxYzg2ZWVmNC1jMjZkLTRiNGUtODEzNy0wYjBiZTEyM2NhMGMiLCJpc3MiOiJodHRwczovL3N0cy53aW5kb3dzLm5ldC80NDc4ODkyMC05Yjk3LTRmOGItODIwYS0yMTFiMTMzZDk1MzgvIiwiaWF0IjoxNTIxMTUyNjMzLCJuYmYiOjE1MjExNTI2MzMsImV4cCI6MTUyMTE1NjUzMywiYWNyIjoiMSIsImFpbyI6IkFWUUFxLzhHQUFBQUptVzkzTFd6dVArcGF4ZzJPeGE1cGp2V1NXV1ZSVnd1ZXZ5QU5yMlNkc0tkQmFWNnNjcHZsbUpmT1dDOThscUJJMDhXdlB6cDdlenpJdzJLai9MdWdXWWdydHhkM1lmaDlYSGpXeFVaWk9JPSIsImFtciI6WyJyc2EiXSwiYXBwaWQiOiJhYTY5ODM1OC0yMWEzLTRhYTQtYjI3OC1mMzI2NTMzMDUzZTkiLCJhcHBpZGFjciI6IjEiLCJlbWFpbCI6Im1pamlhbmdAbWljcm9zb2Z0LmNvbSIsImZhbWlseV9uYW1lIjoiSmlhbmciLCJnaXZlbl9uYW1lIjoiTWlhbyIsImlkcCI6Imh0dHBzOi8vc3RzLndpbmRvd3MubmV0LzcyZjk4OGJmLTg2ZjEtNDFhZi05MWFiLTJkN2NkMDExZGI0Ny8iLCJpcGFkZHIiOiIxMzEuMTA3LjE3NC4xNDAiLCJuYW1lIjoiTWlhbyBKaWFuZyIsIm9pZCI6IjhiMTU4ZDEwLWVmZGItNDUxMS1iOTQzLTczOWZkYjMxNzAyZSIsInNjcCI6InVzZXJfaW1wZXJzb25hdGlvbiIsInN1YiI6IkFGaWtvWFk1TEV1LTNkbk1pa3Z3MUJzQUx4SGIybV9IaVJjaHVfSEM1aGciLCJ0aWQiOiI0NDc4ODkyMC05Yjk3LTRmOGItODIwYS0yMTFiMTMzZDk1MzgiLCJ1bmlxdWVfbmFtZSI6Im1pamlhbmdAbWljcm9zb2Z0LmNvbSIsInV0aSI6ImFQaTJxOVZ6ODBXdHNsYjRBMzBCQUEiLCJ2ZXIiOiIxLjAifQ.agGfaegYRnGj6DM_-N_eYulnQdXHhrsus45QDuApirETDR2P2aMRxRioOCR2YVwn8pmpQ1LoAhddcYMWisrw_qhaQr0AYsDPWRtJ6x0hDk5teUgbix3gazb7F-TVcC1gXpc9y7j77Ujxcq9z0r5lF65Y9bpNSefn9Te6GZYG7BgKEixqC4W6LqjtcjuOuW-ouy6LSSox71Fj4Ni3zkGfxX1T_jiOvQTd6BBltSrShDm0bTMefoyX8oqfMEA2ziKjwvBFrOjO0uK4rJLgLYH4qvkR0bdF9etdstqKMo5gecarWHNzWi_tghQu9aE3Z3EZdYNI_ZGM-Bbe3pkCfvEOyA
   ```

5. Select **Send**, and you can call the API successfully.


## Configure a JWT validation policy to pre-authorize requests

At this point, when a user tries to make a call from the Developer Console, the user is prompted to sign in. The Developer Console obtains an access token on behalf of the user.

But what if someone calls your API without a token or with an invalid token? For example, you can still call the API even if you delete the `Authorization` header. The reason is that API Management does not validate the access token at this point. It simply passes the `Authorization` header to the back-end API.

You can use the [Validate JWT](api-management-access-restriction-policies.md#ValidateJWT) policy to pre-authorize requests in API Management, by validating the access tokens of each incoming request. If a request does not have a valid token, API Management blocks it. For example, you can add the following policy to the `<inbound>` policy section of the `Echo API`. It checks the audience claim in an access token, and returns an error message if the token is not valid. For information on how to configure policies, see [Set or edit policies](set-edit-policies.md).

```xml
<validate-jwt header-name="Authorization" failed-validation-httpcode="401" failed-validation-error-message="Unauthorized. Access token is missing or invalid.">
    <openid-config url="https://login.microsoftonline.com/{aad-tenant}/.well-known/openid-configuration" />
    <required-claims>
        <claim name="aud">
            <value>{Application ID of backend-app}</value>
        </claim>
    </required-claims>
</validate-jwt>
```

## Build an application to call the API

In this guide, you used the Developer Console in API Management as the sample client application to call the `Echo API` protected by OAuth 2.0. To learn more about how to build an application and implement OAuth 2.0, see [Azure Active Directory code samples](../active-directory/develop/sample-v1-code.md).





## Next steps
* Learn more about [Azure Active Directory and OAuth2.0](../active-directory/develop/authentication-scenarios.md).
* Check out more [videos](https://azure.microsoft.com/documentation/videos/index/?services=api-management) about API Management.
* For other ways to secure your back-end service, see [Mutual Certificate authentication](api-management-howto-mutual-certificates.md).

* [Create an API Management service instance](get-started-create-service-instance.md).

* [Manage your first API](import-and-publish.md).
